{"version":3,"sources":["editors/autocomplete.js"],"names":["define","$","jsbin","coder","split","editors","autocomplete","startTagComplete","editor","somethingSelected","str","cur","getCursor","token","getTokenAt","tprop","test","string","start","ch","end","state","className","line","context","push","replaceRange","focus","setCursor"],"mappings":";;;;;;;AAAAA,QACE,iBACC,WACA,YACD,SAAUC,EAAEC,EAAMC,GAgJA,iJAC8DC,MAAM,KACrE,4IACkEA,MAAM,KACzE,4BAA4BA,MAAM,KACnC,yKACsFA,MAAM,KA2C3G,OAAOD,EAAME,QAAQC,cACnBC,iBA3KF,SAA0BC,GAExB,IAAIA,EAAOC,oBAAX,CAEA,IAgBgBC,EAhBZC,EAAMH,EAAOI,WAAU,GAAQC,EAAQL,EAAOM,WAAWH,GAAMI,EAAQF,EAQ3E,IANK,YAAYG,KAAKH,EAAMI,UAC1BJ,EAAQE,GAASG,MAAOP,EAAIQ,GAAIC,IAAKT,EAAIQ,GAAIF,OAAQ,GAAII,MAAOR,EAAMQ,MACrDC,UAA2B,KAAhBT,EAAMI,OAAgB,cAAgB,OAI1C,eAAnBF,EAAMO,WAA4B,CAEvC,GAAoB,MADpBP,EAAQP,EAAOM,YAAYS,KAAMZ,EAAIY,KAAMJ,GAAIJ,EAAMG,SAC3CD,OAAe,OAEzB,GADAF,EAAQP,EAAOM,YAAYS,KAAMZ,EAAIY,KAAMJ,GAAIJ,EAAMG,SAChDM,EAAS,IAAIA,KAClBA,EAAQC,KAAKV,GAUf,OAPgBL,EAIT,QAHLF,EAAOkB,aAAahB,GAAMa,KAAMZ,EAAIY,KAAMJ,GAAIN,EAAMK,QAASK,KAAMZ,EAAIY,KAAMJ,GAAIN,EAAMO,MAIzFZ,EAAOmB,QACPnB,EAAOoB,WAAYL,KAAMZ,EAAIY,KAAMJ,GAAIN,EAAMO,OACtC","file":"../../editors/autocomplete.js","sourcesContent":["define([\r\n  \"skylark-jquery\",\r\n   \"../jsbin\",\r\n   \"../coder\"\r\n],function ($,jsbin,coder) {\r\n\r\n  // Minimal event-handling wrapper.\r\n  function stopEvent() {\r\n    if (this.preventDefault) {this.preventDefault(); this.stopPropagation();}\r\n    else {this.returnValue = false; this.cancelBubble = true;}\r\n  }\r\n  function addStop(event) {\r\n    if (!event.stop) event.stop = stopEvent;\r\n    return event;\r\n  }\r\n  function connect(node, type, handler) {\r\n    function wrapHandler(event) {handler(addStop(event || window.event));}\r\n    if (typeof node.addEventListener == \"function\")\r\n      node.addEventListener(type, wrapHandler, false);\r\n    else\r\n      node.attachEvent(\"on\" + type, wrapHandler);\r\n  }\r\n\r\n  function forEach(arr, f) {\r\n    for (var i = 0, e = arr.length; i < e; ++i) f(arr[i]);\r\n  }\r\n\r\n  function startTagComplete(editor) {\r\n    // We want a single cursor position.\r\n    if (editor.somethingSelected()) return;\r\n    // Find the token at the cursor\r\n    var cur = editor.getCursor(false), token = editor.getTokenAt(cur), tprop = token;\r\n    // If it's not a 'word-style' token, ignore the token.\r\n    if (!/^[\\w$_]*$/.test(token.string)) {\r\n      token = tprop = {start: cur.ch, end: cur.ch, string: \"\", state: token.state,\r\n                       className: token.string == \".\" ? \"js-property\" : null};\r\n    }\r\n    \r\n    // If it is a property, find out what it is a property of.\r\n    while (tprop.className == \"js-property\") {\r\n      tprop = editor.getTokenAt({line: cur.line, ch: tprop.start});\r\n      if (tprop.string != \".\") return;\r\n      tprop = editor.getTokenAt({line: cur.line, ch: tprop.start});\r\n      if (!context) var context = [];\r\n      context.push(tprop);\r\n    }\r\n    \r\n    function insert(str) {\r\n      editor.replaceRange(str, {line: cur.line, ch: token.start}, {line: cur.line, ch: token.end});\r\n    }\r\n    \r\n    insert('<></>');\r\n    editor.focus();\r\n    editor.setCursor({ line: cur.line, ch: token.end });\r\n    return true;\r\n  }\r\n\r\n  function startComplete(editor) {\r\n    // We want a single cursor position.\r\n    if (editor.somethingSelected()) return;\r\n    // Find the token at the cursor\r\n    var cur = editor.getCursor(false), token = editor.getTokenAt(cur), tprop = token;\r\n    // If it's not a 'word-style' token, ignore the token.\r\n\r\n    if (token.string == '') return;\r\n\r\n    if (!/^[\\w$_]*$/.test(token.string)) {\r\n      token = tprop = {start: cur.ch, end: cur.ch, string: \"\", state: token.state,\r\n                       className: token.string == \".\" ? \"js-property\" : null};\r\n    }\r\n    \r\n    // If it is a property, find out what it is a property of.\r\n    while (tprop.className == \"js-property\") {\r\n      tprop = editor.getTokenAt({line: cur.line, ch: tprop.start});\r\n      if (tprop.string != \".\") return;\r\n      tprop = editor.getTokenAt({line: cur.line, ch: tprop.start});\r\n      if (!context) var context = [];\r\n      context.push(tprop);\r\n    }\r\n    \r\n    if (token.string == '' && context === undefined) return;\r\n    \r\n    var completions = getCompletions(token, context, editor);\r\n    if (!completions.length) return;\r\n    function insert(str) {\r\n      editor.replaceRange(str, {line: cur.line, ch: token.start}, {line: cur.line, ch: token.end});\r\n    }\r\n    // When there is only one completion, use it directly.\r\n    if (completions.length == 1) {insert(completions[0]); return true;}\r\n\r\n    // Build the select widget\r\n    var complete = document.createElement(\"div\");\r\n    complete.className = \"completions\";\r\n    var sel = complete.appendChild(document.createElement(\"select\"));\r\n    sel.multiple = true;\r\n    for (var i = 0; i < completions.length; ++i) {\r\n      var opt = sel.appendChild(document.createElement(\"option\"));\r\n      opt.appendChild(document.createTextNode(completions[i]));\r\n    }\r\n    sel.firstChild.selected = true;\r\n    sel.size = Math.min(10, completions.length);\r\n    var pos = editor.cursorCoords();\r\n    complete.style.left = pos.x + \"px\";\r\n    complete.style.top = pos.yBot + \"px\";\r\n    complete.style.position = 'absolute';\r\n    complete.style.outline = 'none';\r\n    complete.className = 'autocomplete';\r\n    document.body.appendChild(complete);\r\n    \r\n    // Hack to hide the scrollbar.\r\n    if (completions.length <= 10) {\r\n      complete.style.width = (sel.clientWidth - 1) + \"px\";\r\n    }\r\n\r\n    var done = false;\r\n    function close() {\r\n      if (done) return;\r\n      done = true;\r\n      complete.parentNode.removeChild(complete);\r\n    }\r\n    function pick() {\r\n      insert(sel.options[sel.selectedIndex].value);\r\n      close();\r\n      setTimeout(function(){editor.focus();}, 50);\r\n    }\r\n    \r\n    function pickandclose() {\r\n      pick()\r\n      setTimeout(function () { editor.focus(); }, 50);\r\n    }\r\n    \r\n    connect(sel, \"blur\", close);\r\n    connect(sel, \"keydown\", function(event) {\r\n      var code = event.keyCode;\r\n      // Enter and space\r\n      if (code == 13 || code == 32) { event.stop(); pick();}\r\n      // Escape\r\n      else if (code == 27) {event.stop(); close(); editor.focus();}\r\n      else if (code != 38 && code != 40) {close(); editor.focus(); setTimeout(function () { startComplete(editor) }, 50);}\r\n    });\r\n    connect(sel, \"dblclick\", pick);\r\n\r\n    sel.focus();\r\n    // Opera sometimes ignores focusing a freshly created node\r\n    if (window.opera) setTimeout(function(){if (!done) sel.focus();}, 100);\r\n    return true;\r\n  }\r\n\r\n  var stringProps = (\"charAt charCodeAt indexOf lastIndexOf substring substr slice trim trimLeft trimRight \" +\r\n                     \"toUpperCase toLowerCase split concat match replace search\").split(\" \");\r\n  var arrayProps = (\"length concat join splice push pop shift unshift slice reverse sort indexOf \" +\r\n                    \"lastIndexOf every some filter forEach map reduce reduceRight \").split(\" \");\r\n  var funcProps = \"prototype apply call bind\".split(\" \");\r\n  var keywords = (\"break case catch continue debugger default delete do else false finally for function \" +\r\n                  \"if in instanceof new null return switch throw true try typeof var void while with\").split(\" \");\r\n\r\n  function getCompletions(token, context, editor) {\r\n    var found = [], start = token.string;\r\n    function maybeAdd(str) {\r\n      if (str && str != start && str.indexOf(start) == 0 && found.indexOf(str) === -1) found.push(str);\r\n    }\r\n    function gatherCompletions(obj) {\r\n      if (typeof obj == \"string\") forEach(stringProps, maybeAdd);\r\n      else if (obj instanceof Array) forEach(arrayProps, maybeAdd);\r\n      else if (obj instanceof Function) forEach(funcProps, maybeAdd);\r\n      for (var name in obj) maybeAdd(name);\r\n    }\r\n\r\n    if (context) {\r\n      // If this is a property, see if it belongs to some object we can\r\n      // find in the current environment.\r\n      var obj = context.pop(), base;\r\n      if (obj.className == \"js-variable\")\r\n        base = window[obj.string];\r\n      else if (obj.className == \"js-string\")\r\n        base = \"\";\r\n      else if (obj.className == \"js-atom\")\r\n        base = 1;\r\n      while (base != null && context.length)\r\n        base = base[context.pop().string];\r\n      if (base != null) gatherCompletions(base);\r\n    }\r\n    else {\r\n      // If not, just look in the window object and any local scope\r\n      // (reading into JS mode internals to get at the local variables)\r\n      for (var v = token.state.localVars; v; v = v.next) maybeAdd(v.name);\r\n      gatherCompletions(window);\r\n      forEach(keywords, maybeAdd);\r\n    }\r\n    \r\n    // also look up symbols in the current document\r\n    var code = editor.getValue().split(/\\W/);\r\n    forEach(code, maybeAdd);\r\n    \r\n    return found;\r\n  }\r\n\r\n  return coder.editors.autocomplete = {\r\n    startTagComplete\r\n  };\r\n});"]}